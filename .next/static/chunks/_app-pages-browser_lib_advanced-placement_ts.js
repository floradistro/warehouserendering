"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_lib_advanced-placement_ts"],{

/***/ "(app-pages-browser)/./lib/advanced-placement.ts":
/*!***********************************!*\
  !*** ./lib/advanced-placement.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AdvancedPlacementManager: function() { return /* binding */ AdvancedPlacementManager; },\n/* harmony export */   getNextRotation: function() { return /* binding */ getNextRotation; },\n/* harmony export */   getPlacementConstraints: function() { return /* binding */ getPlacementConstraints; },\n/* harmony export */   getPreviousRotation: function() { return /* binding */ getPreviousRotation; },\n/* harmony export */   snapRotationToCardinal: function() { return /* binding */ snapRotationToCardinal; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _element_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./element-tools */ \"(app-pages-browser)/./lib/element-tools.ts\");\n\n\nclass AdvancedPlacementManager {\n    /**\n   * Updates mouse position and calculates world position with raycasting\n   */ updateMousePosition(clientX, clientY, canvasRect) {\n        // Convert to normalized device coordinates\n        this.mouse.x = (clientX - canvasRect.left) / canvasRect.width * 2 - 1;\n        this.mouse.y = -((clientY - canvasRect.top) / canvasRect.height) * 2 + 1;\n        // Update raycaster\n        this.raycaster.setFromCamera(this.mouse, this.camera);\n        // First try to intersect with existing objects in the scene\n        const intersects = this.raycaster.intersectObjects(this.scene.children, true);\n        if (intersects.length > 0) {\n            // Use the first intersection point\n            return intersects[0].point;\n        }\n        // Fallback to ground plane intersection\n        const intersection = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n        const hit = this.raycaster.ray.intersectPlane(this.groundPlane, intersection);\n        return hit ? intersection : null;\n    }\n    /**\n   * Finds snap points near the given position with enhanced 1-foot grid and centering\n   */ findSnapPoints(position, elements, templateId) {\n        const snapPoints = [];\n        const template = _element_tools__WEBPACK_IMPORTED_MODULE_0__.ELEMENT_TEMPLATES[templateId];\n        if (!template) return snapPoints;\n        // Enhanced 1-foot grid snap points\n        const gridX = Math.round(position.x / this.gridSize) * this.gridSize;\n        const gridZ = Math.round(position.z / this.gridSize) * this.gridSize;\n        snapPoints.push({\n            position: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(gridX, 0, gridZ),\n            type: \"grid\",\n            confidence: 0.5,\n            description: \"Grid: \".concat(gridX, \"', \").concat(gridZ, \"'\")\n        });\n        // Element-based snap points with enhanced centering\n        for (const element of elements){\n            var _element_metadata;\n            if ((_element_metadata = element.metadata) === null || _element_metadata === void 0 ? void 0 : _element_metadata.isPreview) continue;\n            const elementPos = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(element.position.x, 0, element.position.y);\n            const distance = position.distanceTo(elementPos);\n            if (distance > this.snapTolerance * 3) continue;\n            // Enhanced wall-specific snapping with comprehensive centering\n            if (element.type === \"wall\") {\n                const wallStart = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(element.position.x, 0, element.position.y);\n                const wallEnd = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(element.position.x + element.dimensions.width, 0, element.position.y + element.dimensions.height);\n                // Calculate key points along the wall\n                const wallCenter = wallStart.clone().lerp(wallEnd, 0.5);\n                const wallQuarter1 = wallStart.clone().lerp(wallEnd, 0.25);\n                const wallQuarter3 = wallStart.clone().lerp(wallEnd, 0.75);\n                // Wall endpoints\n                if (position.distanceTo(wallStart) <= this.snapTolerance) {\n                    snapPoints.push({\n                        position: wallStart,\n                        type: \"wall-end\",\n                        element,\n                        confidence: 0.9,\n                        description: \"Wall start: \".concat(element.id.slice(0, 8), \"...\")\n                    });\n                }\n                if (position.distanceTo(wallEnd) <= this.snapTolerance) {\n                    snapPoints.push({\n                        position: wallEnd,\n                        type: \"wall-end\",\n                        element,\n                        confidence: 0.9,\n                        description: \"Wall end: \".concat(element.id.slice(0, 8), \"...\")\n                    });\n                }\n                // Wall center - HIGH PRIORITY for centering\n                if (position.distanceTo(wallCenter) <= this.snapTolerance) {\n                    snapPoints.push({\n                        position: wallCenter,\n                        type: \"wall-center\",\n                        element,\n                        confidence: 0.95,\n                        description: \"⭐ CENTERED on wall: \".concat(element.id.slice(0, 8), \"...\")\n                    });\n                }\n                // Wall quarter points for balanced placement\n                if (position.distanceTo(wallQuarter1) <= this.snapTolerance) {\n                    snapPoints.push({\n                        position: wallQuarter1,\n                        type: \"wall-quarter\",\n                        element,\n                        confidence: 0.85,\n                        description: \"Quarter point (25%) on wall: \".concat(element.id.slice(0, 8), \"...\")\n                    });\n                }\n                if (position.distanceTo(wallQuarter3) <= this.snapTolerance) {\n                    snapPoints.push({\n                        position: wallQuarter3,\n                        type: \"wall-quarter\",\n                        element,\n                        confidence: 0.85,\n                        description: \"Quarter point (75%) on wall: \".concat(element.id.slice(0, 8), \"...\")\n                    });\n                }\n                // 1-foot intervals along the wall length\n                const wallLength = wallStart.distanceTo(wallEnd);\n                const wallDirection = wallEnd.clone().sub(wallStart).normalize();\n                for(let i = 1; i < wallLength; i += 1){\n                    const intervalPoint = wallStart.clone().add(wallDirection.clone().multiplyScalar(i));\n                    if (position.distanceTo(intervalPoint) <= this.snapTolerance) {\n                        snapPoints.push({\n                            position: intervalPoint,\n                            type: \"wall-edge\",\n                            element,\n                            confidence: 0.7,\n                            description: \"\".concat(i, \"' along wall: \").concat(element.id.slice(0, 8), \"...\")\n                        });\n                    }\n                }\n                // Wall-to-wall perpendicular snapping\n                if (template.type === \"wall\") {\n                    const wallVector = wallEnd.clone().sub(wallStart).normalize();\n                    const perpendicular = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(-wallVector.z, 0, wallVector.x);\n                    // Check for perpendicular attachment points\n                    const attachPoint1 = wallStart.clone().add(perpendicular.clone().multiplyScalar(template.defaultDimensions.width));\n                    const attachPoint2 = wallEnd.clone().add(perpendicular.clone().multiplyScalar(template.defaultDimensions.width));\n                    if (position.distanceTo(attachPoint1) <= this.snapTolerance) {\n                        snapPoints.push({\n                            position: attachPoint1,\n                            type: \"corner\",\n                            element,\n                            normal: perpendicular,\n                            confidence: 0.85\n                        });\n                    }\n                    if (position.distanceTo(attachPoint2) <= this.snapTolerance) {\n                        snapPoints.push({\n                            position: attachPoint2,\n                            type: \"corner\",\n                            element,\n                            normal: perpendicular,\n                            confidence: 0.85\n                        });\n                    }\n                }\n            }\n            // Element center snapping\n            if (distance <= this.snapTolerance) {\n                snapPoints.push({\n                    position: elementPos,\n                    type: \"element-center\",\n                    element,\n                    confidence: 0.7\n                });\n            }\n        }\n        // Sort by confidence (highest first)\n        return snapPoints.sort((a, b)=>b.confidence - a.confidence);\n    }\n    /**\n   * Gets the best snap point from available options\n   */ getBestSnapPoint(snapPoints) {\n        return snapPoints.length > 0 ? snapPoints[0] : null;\n    }\n    /**\n   * Creates preview element with proper positioning and rotation\n   */ createPreviewElement(templateId, position) {\n        let rotation = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, snapPoint = arguments.length > 3 ? arguments[3] : void 0;\n        var _snapPoint_element;\n        const template = _element_tools__WEBPACK_IMPORTED_MODULE_0__.ELEMENT_TEMPLATES[templateId];\n        if (!template) return null;\n        let finalPosition = position.clone();\n        let finalRotation = rotation;\n        // Apply snap point positioning\n        if (snapPoint) {\n            finalPosition = snapPoint.position.clone();\n            // Auto-rotate based on snap context\n            if (snapPoint.normal && template.type === \"wall\") {\n                const angle = Math.atan2(snapPoint.normal.z, snapPoint.normal.x);\n                finalRotation = angle;\n            }\n        }\n        // Ensure element is at ground level\n        finalPosition.y = 0;\n        return {\n            id: \"preview-element\",\n            type: template.type,\n            position: {\n                x: finalPosition.x,\n                y: finalPosition.z,\n                z: finalPosition.y\n            },\n            dimensions: {\n                width: template.defaultDimensions.width,\n                height: template.defaultDimensions.height,\n                depth: template.defaultDimensions.depth || 8\n            },\n            color: template.defaultColor,\n            material: template.material,\n            rotation: finalRotation,\n            metadata: {\n                ...template.metadata,\n                isPreview: true,\n                snapPoint: snapPoint === null || snapPoint === void 0 ? void 0 : snapPoint.type,\n                snapElement: snapPoint === null || snapPoint === void 0 ? void 0 : (_snapPoint_element = snapPoint.element) === null || _snapPoint_element === void 0 ? void 0 : _snapPoint_element.id\n            }\n        };\n    }\n    /**\n   * Validates placement based on constraints\n   */ validatePlacement(element, existingElements, constraints) {\n        const errors = [];\n        for (const constraint of constraints){\n            switch(constraint.type){\n                case \"wall-to-wall\":\n                    // Check if wall connects to another wall\n                    const nearbyWalls = existingElements.filter((el)=>{\n                        var _el_metadata;\n                        return el.type === \"wall\" && !((_el_metadata = el.metadata) === null || _el_metadata === void 0 ? void 0 : _el_metadata.isPreview) && this.getElementDistance(element, el) < 2;\n                    });\n                    if (nearbyWalls.length === 0) {\n                        errors.push(\"Wall must connect to another wall\");\n                    }\n                    break;\n                case \"door-in-wall\":\n                case \"window-in-wall\":\n                    // Check if door/window is placed in a wall\n                    const hostWall = existingElements.find((el)=>{\n                        var _el_metadata;\n                        return el.type === \"wall\" && !((_el_metadata = el.metadata) === null || _el_metadata === void 0 ? void 0 : _el_metadata.isPreview) && this.isElementInsideWall(element, el);\n                    });\n                    if (!hostWall) {\n                        errors.push(\"\".concat(element.type, \" must be placed in a wall\"));\n                    }\n                    break;\n                case \"ground-only\":\n                    if (element.position.z !== 0) {\n                        errors.push(\"Element must be placed on the ground\");\n                    }\n                    break;\n            }\n        }\n        return {\n            valid: errors.length === 0,\n            errors\n        };\n    }\n    /**\n   * Helper: Calculate distance between elements\n   */ getElementDistance(el1, el2) {\n        const pos1 = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(el1.position.x, 0, el1.position.y);\n        const pos2 = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(el2.position.x, 0, el2.position.y);\n        return pos1.distanceTo(pos2);\n    }\n    /**\n   * Helper: Check if element is inside a wall\n   */ isElementInsideWall(element, wall) {\n        const elementPos = new three__WEBPACK_IMPORTED_MODULE_1__.Vector2(element.position.x, element.position.y);\n        const wallStart = new three__WEBPACK_IMPORTED_MODULE_1__.Vector2(wall.position.x, wall.position.y);\n        const wallEnd = new three__WEBPACK_IMPORTED_MODULE_1__.Vector2(wall.position.x + wall.dimensions.width, wall.position.y);\n        // Check if element position is on the wall line (with tolerance)\n        const distToWall = elementPos.distanceToSquared(wallStart.lerp(wallEnd, 0.5));\n        return distToWall < (wall.dimensions.height / 2) ** 2;\n    }\n    /**\n   * Update camera reference\n   */ updateCamera(camera) {\n        this.camera = camera;\n    }\n    /**\n   * Update scene reference\n   */ updateScene(scene) {\n        this.scene = scene;\n    }\n    constructor(camera, scene){\n        this.camera = camera;\n        this.scene = scene;\n        this.raycaster = new three__WEBPACK_IMPORTED_MODULE_1__.Raycaster();\n        this.mouse = new three__WEBPACK_IMPORTED_MODULE_1__.Vector2();\n        this.groundPlane = new three__WEBPACK_IMPORTED_MODULE_1__.Plane(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 1, 0), 0);\n        this.snapTolerance = 1.5 // feet - tighter for precise 1-foot grid\n        ;\n        this.gridSize = 1.0 // feet - 1-foot grid intervals\n        ;\n    }\n}\n/**\n * PLACEMENT CONSTRAINTS DEFINITIONS\n */ function getPlacementConstraints(templateId) {\n    const template = _element_tools__WEBPACK_IMPORTED_MODULE_0__.ELEMENT_TEMPLATES[templateId];\n    if (!template) return [];\n    const constraints = [\n        {\n            type: \"ground-only\"\n        } // All elements must be on ground\n    ];\n    switch(template.type){\n        case \"wall\":\n            // Walls should connect to other walls (except first wall)\n            constraints.push({\n                type: \"wall-to-wall\"\n            });\n            break;\n        case \"door\":\n        case \"window\":\n            // Doors and windows must be placed in walls\n            constraints.push({\n                type: template.type === \"door\" ? \"door-in-wall\" : \"window-in-wall\"\n            });\n            break;\n    }\n    return constraints;\n}\n/**\n * ROTATION UTILITIES\n */ function getNextRotation(currentRotation) {\n    let step = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Math.PI / 2;\n    return (currentRotation + step) % (Math.PI * 2);\n}\nfunction getPreviousRotation(currentRotation) {\n    let step = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Math.PI / 2;\n    return (currentRotation - step + Math.PI * 2) % (Math.PI * 2);\n}\nfunction snapRotationToCardinal(rotation) {\n    const cardinals = [\n        0,\n        Math.PI / 2,\n        Math.PI,\n        3 * Math.PI / 2\n    ];\n    let closest = cardinals[0];\n    let minDiff = Math.abs(rotation - closest);\n    for (const cardinal of cardinals){\n        const diff = Math.abs(rotation - cardinal);\n        if (diff < minDiff) {\n            minDiff = diff;\n            closest = cardinal;\n        }\n    }\n    return closest;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9hZHZhbmNlZC1wbGFjZW1lbnQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUE4QjtBQUVxQjtBQWlDNUMsTUFBTUU7SUFZWDs7R0FFQyxHQUNEQyxvQkFDRUMsT0FBZSxFQUNmQyxPQUFlLEVBQ2ZDLFVBQW1CLEVBQ0c7UUFDdEIsMkNBQTJDO1FBQzNDLElBQUksQ0FBQ0MsS0FBSyxDQUFDQyxDQUFDLEdBQUcsQ0FBRUosVUFBVUUsV0FBV0csSUFBSSxJQUFJSCxXQUFXSSxLQUFLLEdBQUksSUFBSTtRQUN0RSxJQUFJLENBQUNILEtBQUssQ0FBQ0ksQ0FBQyxHQUFHLENBQUUsRUFBQ04sVUFBVUMsV0FBV00sR0FBRyxJQUFJTixXQUFXTyxNQUFNLElBQUksSUFBSTtRQUV2RSxtQkFBbUI7UUFDbkIsSUFBSSxDQUFDQyxTQUFTLENBQUNDLGFBQWEsQ0FBQyxJQUFJLENBQUNSLEtBQUssRUFBRSxJQUFJLENBQUNTLE1BQU07UUFFcEQsNERBQTREO1FBQzVELE1BQU1DLGFBQWEsSUFBSSxDQUFDSCxTQUFTLENBQUNJLGdCQUFnQixDQUFDLElBQUksQ0FBQ0MsS0FBSyxDQUFDQyxRQUFRLEVBQUU7UUFFeEUsSUFBSUgsV0FBV0ksTUFBTSxHQUFHLEdBQUc7WUFDekIsbUNBQW1DO1lBQ25DLE9BQU9KLFVBQVUsQ0FBQyxFQUFFLENBQUNLLEtBQUs7UUFDNUI7UUFFQSx3Q0FBd0M7UUFDeEMsTUFBTUMsZUFBZSxJQUFJdkIsMENBQWE7UUFDdEMsTUFBTXlCLE1BQU0sSUFBSSxDQUFDWCxTQUFTLENBQUNZLEdBQUcsQ0FBQ0MsY0FBYyxDQUFDLElBQUksQ0FBQ0MsV0FBVyxFQUFFTDtRQUVoRSxPQUFPRSxNQUFNRixlQUFlO0lBQzlCO0lBRUE7O0dBRUMsR0FDRE0sZUFDRUMsUUFBdUIsRUFDdkJDLFFBQTRCLEVBQzVCQyxVQUFrQixFQUNMO1FBQ2IsTUFBTUMsYUFBMEIsRUFBRTtRQUNsQyxNQUFNQyxXQUFXakMsNkRB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VDtBQUVBOztDQUVDLEdBQ00sU0FBU3lCLGdCQUFnQkMsZUFBdUI7UUFBRUMsT0FBQUEsaUVBQWVyRixLQUFLc0YsRUFBRSxHQUFHO0lBQ2hGLE9BQU8sQ0FBQ0Ysa0JBQWtCQyxJQUFHLElBQU1yRixDQUFBQSxLQUFLc0YsRUFBRSxHQUFHO0FBQy9DO0FBRU8sU0FBU0Msb0JBQW9CSCxlQUF1QjtRQUFFQyxPQUFBQSxpRUFBZXJGLEtBQUtzRixFQUFFLEdBQUc7SUFDcEYsT0FBTyxDQUFDRixrQkFBa0JDLE9BQU9yRixLQUFLc0YsRUFBRSxHQUFHLEtBQU10RixDQUFBQSxLQUFLc0YsRUFBRSxHQUFHO0FBQzdEO0FBRU8sU0FBU0UsdUJBQXVCM0MsUUFBZ0I7SUFDckQsTUFBTTRDLFlBQVk7UUFBQztRQUFHekYsS0FBS3NGLEVBQUUsR0FBRztRQUFHdEYsS0FBS3NGLEVBQUU7UUFBRSxJQUFJdEYsS0FBS3NGLEVBQUUsR0FBRztLQUFFO0lBQzVELElBQUlJLFVBQVVELFNBQVMsQ0FBQyxFQUFFO0lBQzFCLElBQUlFLFVBQVUzRixLQUFLNEYsR0FBRyxDQUFDL0MsV0FBVzZDO0lBRWxDLEtBQUssTUFBTUcsWUFBWUosVUFBVztRQUNoQyxNQUFNSyxPQUFPOUYsS0FBSzRGLEdBQUcsQ0FBQy9DLFdBQVdnRDtRQUNqQyxJQUFJQyxPQUFPSCxTQUFTO1lBQ2xCQSxVQUFVRztZQUNWSixVQUFVRztRQUNaO0lBQ0Y7SUFFQSxPQUFPSDtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9hZHZhbmNlZC1wbGFjZW1lbnQudHM/YmJiMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSdcbmltcG9ydCB7IEZsb29ycGxhbkVsZW1lbnQgfSBmcm9tICcuL3N0b3JlJ1xuaW1wb3J0IHsgRUxFTUVOVF9URU1QTEFURVMgfSBmcm9tICcuL2VsZW1lbnQtdG9vbHMnXG5cbi8qKlxuICogQURWQU5DRUQgUExBQ0VNRU5UIFNZU1RFTVxuICogSGFuZGxlcyBzb3BoaXN0aWNhdGVkIDNEIHBsYWNlbWVudCB3aXRoIHJheWNhc3RpbmcsIHNuYXBwaW5nLCBhbmQgcm90YXRpb25cbiAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIFNuYXBQb2ludCB7XG4gIHBvc2l0aW9uOiBUSFJFRS5WZWN0b3IzXG4gIHR5cGU6ICd3YWxsLWVuZCcgfCAnd2FsbC1taWRkbGUnIHwgJ3dhbGwtY2VudGVyJyB8ICd3YWxsLXF1YXJ0ZXInIHwgJ3dhbGwtZWRnZScgfCAnY29ybmVyJyB8ICdncmlkJyB8ICdlbGVtZW50LWNlbnRlcicgfCAnZWxlbWVudC1lZGdlJ1xuICBlbGVtZW50PzogRmxvb3JwbGFuRWxlbWVudFxuICBub3JtYWw/OiBUSFJFRS5WZWN0b3IzXG4gIGNvbmZpZGVuY2U6IG51bWJlclxuICBkZXNjcmlwdGlvbj86IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBsYWNlbWVudENvbnN0cmFpbnQge1xuICB0eXBlOiAnd2FsbC10by13YWxsJyB8ICdkb29yLWluLXdhbGwnIHwgJ3dpbmRvdy1pbi13YWxsJyB8ICdncm91bmQtb25seSdcbiAgdGFyZ2V0RWxlbWVudD86IEZsb29ycGxhbkVsZW1lbnRcbiAgYWxsb3dlZE9yaWVudGF0aW9ucz86IG51bWJlcltdXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWR2YW5jZWRQbGFjZW1lbnRTdGF0ZSB7XG4gIGlzUGxhY2luZzogYm9vbGVhblxuICB0ZW1wbGF0ZUlkOiBzdHJpbmcgfCBudWxsXG4gIHByZXZpZXdFbGVtZW50OiBGbG9vcnBsYW5FbGVtZW50IHwgbnVsbFxuICBjdXJyZW50Um90YXRpb246IG51bWJlclxuICBzbmFwUG9pbnRzOiBTbmFwUG9pbnRbXVxuICBhY3RpdmVTbmFwUG9pbnQ6IFNuYXBQb2ludCB8IG51bGxcbiAgY29uc3RyYWludHM6IFBsYWNlbWVudENvbnN0cmFpbnRbXVxuICBzaG93U25hcEluZGljYXRvcnM6IGJvb2xlYW5cbn1cblxuZXhwb3J0IGNsYXNzIEFkdmFuY2VkUGxhY2VtZW50TWFuYWdlciB7XG4gIHByaXZhdGUgcmF5Y2FzdGVyID0gbmV3IFRIUkVFLlJheWNhc3RlcigpXG4gIHByaXZhdGUgbW91c2UgPSBuZXcgVEhSRUUuVmVjdG9yMigpXG4gIHByaXZhdGUgZ3JvdW5kUGxhbmUgPSBuZXcgVEhSRUUuUGxhbmUobmV3IFRIUkVFLlZlY3RvcjMoMCwgMSwgMCksIDApXG4gIHByaXZhdGUgc25hcFRvbGVyYW5jZSA9IDEuNSAvLyBmZWV0IC0gdGlnaHRlciBmb3IgcHJlY2lzZSAxLWZvb3QgZ3JpZFxuICBwcml2YXRlIGdyaWRTaXplID0gMS4wIC8vIGZlZXQgLSAxLWZvb3QgZ3JpZCBpbnRlcnZhbHNcbiAgXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgY2FtZXJhOiBUSFJFRS5DYW1lcmEsXG4gICAgcHJpdmF0ZSBzY2VuZTogVEhSRUUuU2NlbmVcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIG1vdXNlIHBvc2l0aW9uIGFuZCBjYWxjdWxhdGVzIHdvcmxkIHBvc2l0aW9uIHdpdGggcmF5Y2FzdGluZ1xuICAgKi9cbiAgdXBkYXRlTW91c2VQb3NpdGlvbihcbiAgICBjbGllbnRYOiBudW1iZXIsIFxuICAgIGNsaWVudFk6IG51bWJlciwgXG4gICAgY2FudmFzUmVjdDogRE9NUmVjdFxuICApOiBUSFJFRS5WZWN0b3IzIHwgbnVsbCB7XG4gICAgLy8gQ29udmVydCB0byBub3JtYWxpemVkIGRldmljZSBjb29yZGluYXRlc1xuICAgIHRoaXMubW91c2UueCA9ICgoY2xpZW50WCAtIGNhbnZhc1JlY3QubGVmdCkgLyBjYW52YXNSZWN0LndpZHRoKSAqIDIgLSAxXG4gICAgdGhpcy5tb3VzZS55ID0gLSgoY2xpZW50WSAtIGNhbnZhc1JlY3QudG9wKSAvIGNhbnZhc1JlY3QuaGVpZ2h0KSAqIDIgKyAxXG5cbiAgICAvLyBVcGRhdGUgcmF5Y2FzdGVyXG4gICAgdGhpcy5yYXljYXN0ZXIuc2V0RnJvbUNhbWVyYSh0aGlzLm1vdXNlLCB0aGlzLmNhbWVyYSlcblxuICAgIC8vIEZpcnN0IHRyeSB0byBpbnRlcnNlY3Qgd2l0aCBleGlzdGluZyBvYmplY3RzIGluIHRoZSBzY2VuZVxuICAgIGNvbnN0IGludGVyc2VjdHMgPSB0aGlzLnJheWNhc3Rlci5pbnRlcnNlY3RPYmplY3RzKHRoaXMuc2NlbmUuY2hpbGRyZW4sIHRydWUpXG4gICAgXG4gICAgaWYgKGludGVyc2VjdHMubGVuZ3RoID4gMCkge1xuICAgICAgLy8gVXNlIHRoZSBmaXJzdCBpbnRlcnNlY3Rpb24gcG9pbnRcbiAgICAgIHJldHVybiBpbnRlcnNlY3RzWzBdLnBvaW50XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgdG8gZ3JvdW5kIHBsYW5lIGludGVyc2VjdGlvblxuICAgIGNvbnN0IGludGVyc2VjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKClcbiAgICBjb25zdCBoaXQgPSB0aGlzLnJheWNhc3Rlci5yYXkuaW50ZXJzZWN0UGxhbmUodGhpcy5ncm91bmRQbGFuZSwgaW50ZXJzZWN0aW9uKVxuICAgIFxuICAgIHJldHVybiBoaXQgPyBpbnRlcnNlY3Rpb24gOiBudWxsXG4gIH1cblxuICAvKipcbiAgICogRmluZHMgc25hcCBwb2ludHMgbmVhciB0aGUgZ2l2ZW4gcG9zaXRpb24gd2l0aCBlbmhhbmNlZCAxLWZvb3QgZ3JpZCBhbmQgY2VudGVyaW5nXG4gICAqL1xuICBmaW5kU25hcFBvaW50cyhcbiAgICBwb3NpdGlvbjogVEhSRUUuVmVjdG9yMywgXG4gICAgZWxlbWVudHM6IEZsb29ycGxhbkVsZW1lbnRbXSxcbiAgICB0ZW1wbGF0ZUlkOiBzdHJpbmdcbiAgKTogU25hcFBvaW50W10ge1xuICAgIGNvbnN0IHNuYXBQb2ludHM6IFNuYXBQb2ludFtdID0gW11cbiAgICBjb25zdCB0ZW1wbGF0ZSA9IEVMRU1FTlRfVEVNUExBVEVTW3RlbXBsYXRlSWRdXG4gICAgXG4gICAgaWYgKCF0ZW1wbGF0ZSkgcmV0dXJuIHNuYXBQb2ludHNcblxuICAgIC8vIEVuaGFuY2VkIDEtZm9vdCBncmlkIHNuYXAgcG9pbnRzXG4gICAgY29uc3QgZ3JpZFggPSBNYXRoLnJvdW5kKHBvc2l0aW9uLnggLyB0aGlzLmdyaWRTaXplKSAqIHRoaXMuZ3JpZFNpemVcbiAgICBjb25zdCBncmlkWiA9IE1hdGgucm91bmQocG9zaXRpb24ueiAvIHRoaXMuZ3JpZFNpemUpICogdGhpcy5ncmlkU2l6ZVxuICAgIHNuYXBQb2ludHMucHVzaCh7XG4gICAgICBwb3NpdGlvbjogbmV3IFRIUkVFLlZlY3RvcjMoZ3JpZFgsIDAsIGdyaWRaKSxcbiAgICAgIHR5cGU6ICdncmlkJyxcbiAgICAgIGNvbmZpZGVuY2U6IDAuNSxcbiAgICAgIGRlc2NyaXB0aW9uOiBgR3JpZDogJHtncmlkWH0nLCAke2dyaWRafSdgXG4gICAgfSlcblxuICAgIC8vIEVsZW1lbnQtYmFzZWQgc25hcCBwb2ludHMgd2l0aCBlbmhhbmNlZCBjZW50ZXJpbmdcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgIGlmIChlbGVtZW50Lm1ldGFkYXRhPy5pc1ByZXZpZXcpIGNvbnRpbnVlXG5cbiAgICAgIGNvbnN0IGVsZW1lbnRQb3MgPSBuZXcgVEhSRUUuVmVjdG9yMyhlbGVtZW50LnBvc2l0aW9uLngsIDAsIGVsZW1lbnQucG9zaXRpb24ueSlcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gcG9zaXRpb24uZGlzdGFuY2VUbyhlbGVtZW50UG9zKVxuICAgICAgXG4gICAgICBpZiAoZGlzdGFuY2UgPiB0aGlzLnNuYXBUb2xlcmFuY2UgKiAzKSBjb250aW51ZVxuXG4gICAgICAvLyBFbmhhbmNlZCB3YWxsLXNwZWNpZmljIHNuYXBwaW5nIHdpdGggY29tcHJlaGVuc2l2ZSBjZW50ZXJpbmdcbiAgICAgIGlmIChlbGVtZW50LnR5cGUgPT09ICd3YWxsJykge1xuICAgICAgICBjb25zdCB3YWxsU3RhcnQgPSBuZXcgVEhSRUUuVmVjdG9yMyhlbGVtZW50LnBvc2l0aW9uLngsIDAsIGVsZW1lbnQucG9zaXRpb24ueSlcbiAgICAgICAgY29uc3Qgd2FsbEVuZCA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgICAgIGVsZW1lbnQucG9zaXRpb24ueCArIGVsZW1lbnQuZGltZW5zaW9ucy53aWR0aCwgXG4gICAgICAgICAgMCwgXG4gICAgICAgICAgZWxlbWVudC5wb3NpdGlvbi55ICsgZWxlbWVudC5kaW1lbnNpb25zLmhlaWdodFxuICAgICAgICApXG4gICAgICAgIFxuICAgICAgICAvLyBDYWxjdWxhdGUga2V5IHBvaW50cyBhbG9uZyB0aGUgd2FsbFxuICAgICAgICBjb25zdCB3YWxsQ2VudGVyID0gd2FsbFN0YXJ0LmNsb25lKCkubGVycCh3YWxsRW5kLCAwLjUpXG4gICAgICAgIGNvbnN0IHdhbGxRdWFydGVyMSA9IHdhbGxTdGFydC5jbG9uZSgpLmxlcnAod2FsbEVuZCwgMC4yNSlcbiAgICAgICAgY29uc3Qgd2FsbFF1YXJ0ZXIzID0gd2FsbFN0YXJ0LmNsb25lKCkubGVycCh3YWxsRW5kLCAwLjc1KVxuICAgICAgICBcbiAgICAgICAgLy8gV2FsbCBlbmRwb2ludHNcbiAgICAgICAgaWYgKHBvc2l0aW9uLmRpc3RhbmNlVG8od2FsbFN0YXJ0KSA8PSB0aGlzLnNuYXBUb2xlcmFuY2UpIHtcbiAgICAgICAgICBzbmFwUG9pbnRzLnB1c2goe1xuICAgICAgICAgICAgcG9zaXRpb246IHdhbGxTdGFydCxcbiAgICAgICAgICAgIHR5cGU6ICd3YWxsLWVuZCcsXG4gICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgY29uZmlkZW5jZTogMC45LFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBXYWxsIHN0YXJ0OiAke2VsZW1lbnQuaWQuc2xpY2UoMCwgOCl9Li4uYFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChwb3NpdGlvbi5kaXN0YW5jZVRvKHdhbGxFbmQpIDw9IHRoaXMuc25hcFRvbGVyYW5jZSkge1xuICAgICAgICAgIHNuYXBQb2ludHMucHVzaCh7XG4gICAgICAgICAgICBwb3NpdGlvbjogd2FsbEVuZCxcbiAgICAgICAgICAgIHR5cGU6ICd3YWxsLWVuZCcsXG4gICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgY29uZmlkZW5jZTogMC45LFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBXYWxsIGVuZDogJHtlbGVtZW50LmlkLnNsaWNlKDAsIDgpfS4uLmBcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2FsbCBjZW50ZXIgLSBISUdIIFBSSU9SSVRZIGZvciBjZW50ZXJpbmdcbiAgICAgICAgaWYgKHBvc2l0aW9uLmRpc3RhbmNlVG8od2FsbENlbnRlcikgPD0gdGhpcy5zbmFwVG9sZXJhbmNlKSB7XG4gICAgICAgICAgc25hcFBvaW50cy5wdXNoKHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiB3YWxsQ2VudGVyLFxuICAgICAgICAgICAgdHlwZTogJ3dhbGwtY2VudGVyJyxcbiAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICBjb25maWRlbmNlOiAwLjk1LFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGDirZAgQ0VOVEVSRUQgb24gd2FsbDogJHtlbGVtZW50LmlkLnNsaWNlKDAsIDgpfS4uLmBcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBXYWxsIHF1YXJ0ZXIgcG9pbnRzIGZvciBiYWxhbmNlZCBwbGFjZW1lbnRcbiAgICAgICAgaWYgKHBvc2l0aW9uLmRpc3RhbmNlVG8od2FsbFF1YXJ0ZXIxKSA8PSB0aGlzLnNuYXBUb2xlcmFuY2UpIHtcbiAgICAgICAgICBzbmFwUG9pbnRzLnB1c2goe1xuICAgICAgICAgICAgcG9zaXRpb246IHdhbGxRdWFydGVyMSxcbiAgICAgICAgICAgIHR5cGU6ICd3YWxsLXF1YXJ0ZXInLFxuICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgIGNvbmZpZGVuY2U6IDAuODUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYFF1YXJ0ZXIgcG9pbnQgKDI1JSkgb24gd2FsbDogJHtlbGVtZW50LmlkLnNsaWNlKDAsIDgpfS4uLmBcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAocG9zaXRpb24uZGlzdGFuY2VUbyh3YWxsUXVhcnRlcjMpIDw9IHRoaXMuc25hcFRvbGVyYW5jZSkge1xuICAgICAgICAgIHNuYXBQb2ludHMucHVzaCh7XG4gICAgICAgICAgICBwb3NpdGlvbjogd2FsbFF1YXJ0ZXIzLFxuICAgICAgICAgICAgdHlwZTogJ3dhbGwtcXVhcnRlcicsXG4gICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgY29uZmlkZW5jZTogMC44NSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgUXVhcnRlciBwb2ludCAoNzUlKSBvbiB3YWxsOiAke2VsZW1lbnQuaWQuc2xpY2UoMCwgOCl9Li4uYFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIDEtZm9vdCBpbnRlcnZhbHMgYWxvbmcgdGhlIHdhbGwgbGVuZ3RoXG4gICAgICAgIGNvbnN0IHdhbGxMZW5ndGggPSB3YWxsU3RhcnQuZGlzdGFuY2VUbyh3YWxsRW5kKVxuICAgICAgICBjb25zdCB3YWxsRGlyZWN0aW9uID0gd2FsbEVuZC5jbG9uZSgpLnN1Yih3YWxsU3RhcnQpLm5vcm1hbGl6ZSgpXG4gICAgICAgIFxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHdhbGxMZW5ndGg7IGkgKz0gMSkgeyAvLyBFdmVyeSAxIGZvb3RcbiAgICAgICAgICBjb25zdCBpbnRlcnZhbFBvaW50ID0gd2FsbFN0YXJ0LmNsb25lKCkuYWRkKHdhbGxEaXJlY3Rpb24uY2xvbmUoKS5tdWx0aXBseVNjYWxhcihpKSlcbiAgICAgICAgICBpZiAocG9zaXRpb24uZGlzdGFuY2VUbyhpbnRlcnZhbFBvaW50KSA8PSB0aGlzLnNuYXBUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgIHNuYXBQb2ludHMucHVzaCh7XG4gICAgICAgICAgICAgIHBvc2l0aW9uOiBpbnRlcnZhbFBvaW50LFxuICAgICAgICAgICAgICB0eXBlOiAnd2FsbC1lZGdlJyxcbiAgICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgICAgY29uZmlkZW5jZTogMC43LFxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogYCR7aX0nIGFsb25nIHdhbGw6ICR7ZWxlbWVudC5pZC5zbGljZSgwLCA4KX0uLi5gXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdhbGwtdG8td2FsbCBwZXJwZW5kaWN1bGFyIHNuYXBwaW5nXG4gICAgICAgIGlmICh0ZW1wbGF0ZS50eXBlID09PSAnd2FsbCcpIHtcbiAgICAgICAgICBjb25zdCB3YWxsVmVjdG9yID0gd2FsbEVuZC5jbG9uZSgpLnN1Yih3YWxsU3RhcnQpLm5vcm1hbGl6ZSgpXG4gICAgICAgICAgY29uc3QgcGVycGVuZGljdWxhciA9IG5ldyBUSFJFRS5WZWN0b3IzKC13YWxsVmVjdG9yLnosIDAsIHdhbGxWZWN0b3IueClcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDaGVjayBmb3IgcGVycGVuZGljdWxhciBhdHRhY2htZW50IHBvaW50c1xuICAgICAgICAgIGNvbnN0IGF0dGFjaFBvaW50MSA9IHdhbGxTdGFydC5jbG9uZSgpLmFkZChwZXJwZW5kaWN1bGFyLmNsb25lKCkubXVsdGlwbHlTY2FsYXIodGVtcGxhdGUuZGVmYXVsdERpbWVuc2lvbnMud2lkdGgpKVxuICAgICAgICAgIGNvbnN0IGF0dGFjaFBvaW50MiA9IHdhbGxFbmQuY2xvbmUoKS5hZGQocGVycGVuZGljdWxhci5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKHRlbXBsYXRlLmRlZmF1bHREaW1lbnNpb25zLndpZHRoKSlcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAocG9zaXRpb24uZGlzdGFuY2VUbyhhdHRhY2hQb2ludDEpIDw9IHRoaXMuc25hcFRvbGVyYW5jZSkge1xuICAgICAgICAgICAgc25hcFBvaW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgcG9zaXRpb246IGF0dGFjaFBvaW50MSxcbiAgICAgICAgICAgICAgdHlwZTogJ2Nvcm5lcicsXG4gICAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICAgIG5vcm1hbDogcGVycGVuZGljdWxhcixcbiAgICAgICAgICAgICAgY29uZmlkZW5jZTogMC44NVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHBvc2l0aW9uLmRpc3RhbmNlVG8oYXR0YWNoUG9pbnQyKSA8PSB0aGlzLnNuYXBUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgIHNuYXBQb2ludHMucHVzaCh7XG4gICAgICAgICAgICAgIHBvc2l0aW9uOiBhdHRhY2hQb2ludDIsXG4gICAgICAgICAgICAgIHR5cGU6ICdjb3JuZXInLFxuICAgICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgICBub3JtYWw6IHBlcnBlbmRpY3VsYXIsXG4gICAgICAgICAgICAgIGNvbmZpZGVuY2U6IDAuODVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEVsZW1lbnQgY2VudGVyIHNuYXBwaW5nXG4gICAgICBpZiAoZGlzdGFuY2UgPD0gdGhpcy5zbmFwVG9sZXJhbmNlKSB7XG4gICAgICAgIHNuYXBQb2ludHMucHVzaCh7XG4gICAgICAgICAgcG9zaXRpb246IGVsZW1lbnRQb3MsXG4gICAgICAgICAgdHlwZTogJ2VsZW1lbnQtY2VudGVyJyxcbiAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgIGNvbmZpZGVuY2U6IDAuN1xuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNvcnQgYnkgY29uZmlkZW5jZSAoaGlnaGVzdCBmaXJzdClcbiAgICByZXR1cm4gc25hcFBvaW50cy5zb3J0KChhLCBiKSA9PiBiLmNvbmZpZGVuY2UgLSBhLmNvbmZpZGVuY2UpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgYmVzdCBzbmFwIHBvaW50IGZyb20gYXZhaWxhYmxlIG9wdGlvbnNcbiAgICovXG4gIGdldEJlc3RTbmFwUG9pbnQoc25hcFBvaW50czogU25hcFBvaW50W10pOiBTbmFwUG9pbnQgfCBudWxsIHtcbiAgICByZXR1cm4gc25hcFBvaW50cy5sZW5ndGggPiAwID8gc25hcFBvaW50c1swXSA6IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHByZXZpZXcgZWxlbWVudCB3aXRoIHByb3BlciBwb3NpdGlvbmluZyBhbmQgcm90YXRpb25cbiAgICovXG4gIGNyZWF0ZVByZXZpZXdFbGVtZW50KFxuICAgIHRlbXBsYXRlSWQ6IHN0cmluZyxcbiAgICBwb3NpdGlvbjogVEhSRUUuVmVjdG9yMyxcbiAgICByb3RhdGlvbjogbnVtYmVyID0gMCxcbiAgICBzbmFwUG9pbnQ/OiBTbmFwUG9pbnQgfCBudWxsXG4gICk6IEZsb29ycGxhbkVsZW1lbnQgfCBudWxsIHtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IEVMRU1FTlRfVEVNUExBVEVTW3RlbXBsYXRlSWRdXG4gICAgaWYgKCF0ZW1wbGF0ZSkgcmV0dXJuIG51bGxcblxuICAgIGxldCBmaW5hbFBvc2l0aW9uID0gcG9zaXRpb24uY2xvbmUoKVxuICAgIGxldCBmaW5hbFJvdGF0aW9uID0gcm90YXRpb25cblxuICAgIC8vIEFwcGx5IHNuYXAgcG9pbnQgcG9zaXRpb25pbmdcbiAgICBpZiAoc25hcFBvaW50KSB7XG4gICAgICBmaW5hbFBvc2l0aW9uID0gc25hcFBvaW50LnBvc2l0aW9uLmNsb25lKClcbiAgICAgIFxuICAgICAgLy8gQXV0by1yb3RhdGUgYmFzZWQgb24gc25hcCBjb250ZXh0XG4gICAgICBpZiAoc25hcFBvaW50Lm5vcm1hbCAmJiB0ZW1wbGF0ZS50eXBlID09PSAnd2FsbCcpIHtcbiAgICAgICAgY29uc3QgYW5nbGUgPSBNYXRoLmF0YW4yKHNuYXBQb2ludC5ub3JtYWwueiwgc25hcFBvaW50Lm5vcm1hbC54KVxuICAgICAgICBmaW5hbFJvdGF0aW9uID0gYW5nbGVcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgZWxlbWVudCBpcyBhdCBncm91bmQgbGV2ZWxcbiAgICBmaW5hbFBvc2l0aW9uLnkgPSAwXG5cbiAgICByZXR1cm4ge1xuICAgICAgaWQ6ICdwcmV2aWV3LWVsZW1lbnQnLFxuICAgICAgdHlwZTogdGVtcGxhdGUudHlwZSxcbiAgICAgIHBvc2l0aW9uOiB7IFxuICAgICAgICB4OiBmaW5hbFBvc2l0aW9uLngsIFxuICAgICAgICB5OiBmaW5hbFBvc2l0aW9uLnosIFxuICAgICAgICB6OiBmaW5hbFBvc2l0aW9uLnkgXG4gICAgICB9LFxuICAgICAgZGltZW5zaW9uczoge1xuICAgICAgICB3aWR0aDogdGVtcGxhdGUuZGVmYXVsdERpbWVuc2lvbnMud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGVtcGxhdGUuZGVmYXVsdERpbWVuc2lvbnMuaGVpZ2h0LFxuICAgICAgICBkZXB0aDogdGVtcGxhdGUuZGVmYXVsdERpbWVuc2lvbnMuZGVwdGggfHwgOFxuICAgICAgfSxcbiAgICAgIGNvbG9yOiB0ZW1wbGF0ZS5kZWZhdWx0Q29sb3IsXG4gICAgICBtYXRlcmlhbDogdGVtcGxhdGUubWF0ZXJpYWwsXG4gICAgICByb3RhdGlvbjogZmluYWxSb3RhdGlvbixcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIC4uLnRlbXBsYXRlLm1ldGFkYXRhLFxuICAgICAgICBpc1ByZXZpZXc6IHRydWUsXG4gICAgICAgIHNuYXBQb2ludDogc25hcFBvaW50Py50eXBlLFxuICAgICAgICBzbmFwRWxlbWVudDogc25hcFBvaW50Py5lbGVtZW50Py5pZFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgcGxhY2VtZW50IGJhc2VkIG9uIGNvbnN0cmFpbnRzXG4gICAqL1xuICB2YWxpZGF0ZVBsYWNlbWVudChcbiAgICBlbGVtZW50OiBGbG9vcnBsYW5FbGVtZW50LFxuICAgIGV4aXN0aW5nRWxlbWVudHM6IEZsb29ycGxhbkVsZW1lbnRbXSxcbiAgICBjb25zdHJhaW50czogUGxhY2VtZW50Q29uc3RyYWludFtdXG4gICk6IHsgdmFsaWQ6IGJvb2xlYW47IGVycm9yczogc3RyaW5nW10gfSB7XG4gICAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdXG5cbiAgICBmb3IgKGNvbnN0IGNvbnN0cmFpbnQgb2YgY29uc3RyYWludHMpIHtcbiAgICAgIHN3aXRjaCAoY29uc3RyYWludC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3dhbGwtdG8td2FsbCc6XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgd2FsbCBjb25uZWN0cyB0byBhbm90aGVyIHdhbGxcbiAgICAgICAgICBjb25zdCBuZWFyYnlXYWxscyA9IGV4aXN0aW5nRWxlbWVudHMuZmlsdGVyKGVsID0+IFxuICAgICAgICAgICAgZWwudHlwZSA9PT0gJ3dhbGwnICYmIFxuICAgICAgICAgICAgIWVsLm1ldGFkYXRhPy5pc1ByZXZpZXcgJiZcbiAgICAgICAgICAgIHRoaXMuZ2V0RWxlbWVudERpc3RhbmNlKGVsZW1lbnQsIGVsKSA8IDJcbiAgICAgICAgICApXG4gICAgICAgICAgaWYgKG5lYXJieVdhbGxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goJ1dhbGwgbXVzdCBjb25uZWN0IHRvIGFub3RoZXIgd2FsbCcpXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSAnZG9vci1pbi13YWxsJzpcbiAgICAgICAgY2FzZSAnd2luZG93LWluLXdhbGwnOlxuICAgICAgICAgIC8vIENoZWNrIGlmIGRvb3Ivd2luZG93IGlzIHBsYWNlZCBpbiBhIHdhbGxcbiAgICAgICAgICBjb25zdCBob3N0V2FsbCA9IGV4aXN0aW5nRWxlbWVudHMuZmluZChlbCA9PlxuICAgICAgICAgICAgZWwudHlwZSA9PT0gJ3dhbGwnICYmIFxuICAgICAgICAgICAgIWVsLm1ldGFkYXRhPy5pc1ByZXZpZXcgJiZcbiAgICAgICAgICAgIHRoaXMuaXNFbGVtZW50SW5zaWRlV2FsbChlbGVtZW50LCBlbClcbiAgICAgICAgICApXG4gICAgICAgICAgaWYgKCFob3N0V2FsbCkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goYCR7ZWxlbWVudC50eXBlfSBtdXN0IGJlIHBsYWNlZCBpbiBhIHdhbGxgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJ2dyb3VuZC1vbmx5JzpcbiAgICAgICAgICBpZiAoZWxlbWVudC5wb3NpdGlvbi56ICE9PSAwKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCgnRWxlbWVudCBtdXN0IGJlIHBsYWNlZCBvbiB0aGUgZ3JvdW5kJylcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmFsaWQ6IGVycm9ycy5sZW5ndGggPT09IDAsXG4gICAgICBlcnJvcnNcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyOiBDYWxjdWxhdGUgZGlzdGFuY2UgYmV0d2VlbiBlbGVtZW50c1xuICAgKi9cbiAgcHJpdmF0ZSBnZXRFbGVtZW50RGlzdGFuY2UoZWwxOiBGbG9vcnBsYW5FbGVtZW50LCBlbDI6IEZsb29ycGxhbkVsZW1lbnQpOiBudW1iZXIge1xuICAgIGNvbnN0IHBvczEgPSBuZXcgVEhSRUUuVmVjdG9yMyhlbDEucG9zaXRpb24ueCwgMCwgZWwxLnBvc2l0aW9uLnkpXG4gICAgY29uc3QgcG9zMiA9IG5ldyBUSFJFRS5WZWN0b3IzKGVsMi5wb3NpdGlvbi54LCAwLCBlbDIucG9zaXRpb24ueSlcbiAgICByZXR1cm4gcG9zMS5kaXN0YW5jZVRvKHBvczIpXG4gIH1cblxuICAvKipcbiAgICogSGVscGVyOiBDaGVjayBpZiBlbGVtZW50IGlzIGluc2lkZSBhIHdhbGxcbiAgICovXG4gIHByaXZhdGUgaXNFbGVtZW50SW5zaWRlV2FsbChlbGVtZW50OiBGbG9vcnBsYW5FbGVtZW50LCB3YWxsOiBGbG9vcnBsYW5FbGVtZW50KTogYm9vbGVhbiB7XG4gICAgY29uc3QgZWxlbWVudFBvcyA9IG5ldyBUSFJFRS5WZWN0b3IyKGVsZW1lbnQucG9zaXRpb24ueCwgZWxlbWVudC5wb3NpdGlvbi55KVxuICAgIGNvbnN0IHdhbGxTdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IyKHdhbGwucG9zaXRpb24ueCwgd2FsbC5wb3NpdGlvbi55KVxuICAgIGNvbnN0IHdhbGxFbmQgPSBuZXcgVEhSRUUuVmVjdG9yMihcbiAgICAgIHdhbGwucG9zaXRpb24ueCArIHdhbGwuZGltZW5zaW9ucy53aWR0aCxcbiAgICAgIHdhbGwucG9zaXRpb24ueVxuICAgIClcbiAgICBcbiAgICAvLyBDaGVjayBpZiBlbGVtZW50IHBvc2l0aW9uIGlzIG9uIHRoZSB3YWxsIGxpbmUgKHdpdGggdG9sZXJhbmNlKVxuICAgIGNvbnN0IGRpc3RUb1dhbGwgPSBlbGVtZW50UG9zLmRpc3RhbmNlVG9TcXVhcmVkKFxuICAgICAgd2FsbFN0YXJ0LmxlcnAod2FsbEVuZCwgMC41KVxuICAgIClcbiAgICBcbiAgICByZXR1cm4gZGlzdFRvV2FsbCA8ICh3YWxsLmRpbWVuc2lvbnMuaGVpZ2h0IC8gMikgKiogMlxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBjYW1lcmEgcmVmZXJlbmNlXG4gICAqL1xuICB1cGRhdGVDYW1lcmEoY2FtZXJhOiBUSFJFRS5DYW1lcmEpIHtcbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBzY2VuZSByZWZlcmVuY2VcbiAgICovXG4gIHVwZGF0ZVNjZW5lKHNjZW5lOiBUSFJFRS5TY2VuZSkge1xuICAgIHRoaXMuc2NlbmUgPSBzY2VuZVxuICB9XG59XG5cbi8qKlxuICogUExBQ0VNRU5UIENPTlNUUkFJTlRTIERFRklOSVRJT05TXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQbGFjZW1lbnRDb25zdHJhaW50cyh0ZW1wbGF0ZUlkOiBzdHJpbmcpOiBQbGFjZW1lbnRDb25zdHJhaW50W10ge1xuICBjb25zdCB0ZW1wbGF0ZSA9IEVMRU1FTlRfVEVNUExBVEVTW3RlbXBsYXRlSWRdXG4gIGlmICghdGVtcGxhdGUpIHJldHVybiBbXVxuXG4gIGNvbnN0IGNvbnN0cmFpbnRzOiBQbGFjZW1lbnRDb25zdHJhaW50W10gPSBbXG4gICAgeyB0eXBlOiAnZ3JvdW5kLW9ubHknIH0gLy8gQWxsIGVsZW1lbnRzIG11c3QgYmUgb24gZ3JvdW5kXG4gIF1cblxuICBzd2l0Y2ggKHRlbXBsYXRlLnR5cGUpIHtcbiAgICBjYXNlICd3YWxsJzpcbiAgICAgIC8vIFdhbGxzIHNob3VsZCBjb25uZWN0IHRvIG90aGVyIHdhbGxzIChleGNlcHQgZmlyc3Qgd2FsbClcbiAgICAgIGNvbnN0cmFpbnRzLnB1c2goeyB0eXBlOiAnd2FsbC10by13YWxsJyB9KVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgJ2Rvb3InOlxuICAgIGNhc2UgJ3dpbmRvdyc6XG4gICAgICAvLyBEb29ycyBhbmQgd2luZG93cyBtdXN0IGJlIHBsYWNlZCBpbiB3YWxsc1xuICAgICAgY29uc3RyYWludHMucHVzaCh7IFxuICAgICAgICB0eXBlOiB0ZW1wbGF0ZS50eXBlID09PSAnZG9vcicgPyAnZG9vci1pbi13YWxsJyA6ICd3aW5kb3ctaW4td2FsbCcgXG4gICAgICB9KVxuICAgICAgYnJlYWtcbiAgfVxuXG4gIHJldHVybiBjb25zdHJhaW50c1xufVxuXG4vKipcbiAqIFJPVEFUSU9OIFVUSUxJVElFU1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TmV4dFJvdGF0aW9uKGN1cnJlbnRSb3RhdGlvbjogbnVtYmVyLCBzdGVwOiBudW1iZXIgPSBNYXRoLlBJIC8gMik6IG51bWJlciB7XG4gIHJldHVybiAoY3VycmVudFJvdGF0aW9uICsgc3RlcCkgJSAoTWF0aC5QSSAqIDIpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcmV2aW91c1JvdGF0aW9uKGN1cnJlbnRSb3RhdGlvbjogbnVtYmVyLCBzdGVwOiBudW1iZXIgPSBNYXRoLlBJIC8gMik6IG51bWJlciB7XG4gIHJldHVybiAoY3VycmVudFJvdGF0aW9uIC0gc3RlcCArIE1hdGguUEkgKiAyKSAlIChNYXRoLlBJICogMilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNuYXBSb3RhdGlvblRvQ2FyZGluYWwocm90YXRpb246IG51bWJlcik6IG51bWJlciB7XG4gIGNvbnN0IGNhcmRpbmFscyA9IFswLCBNYXRoLlBJIC8gMiwgTWF0aC5QSSwgMyAqIE1hdGguUEkgLyAyXVxuICBsZXQgY2xvc2VzdCA9IGNhcmRpbmFsc1swXVxuICBsZXQgbWluRGlmZiA9IE1hdGguYWJzKHJvdGF0aW9uIC0gY2xvc2VzdClcblxuICBmb3IgKGNvbnN0IGNhcmRpbmFsIG9mIGNhcmRpbmFscykge1xuICAgIGNvbnN0IGRpZmYgPSBNYXRoLmFicyhyb3RhdGlvbiAtIGNhcmRpbmFsKVxuICAgIGlmIChkaWZmIDwgbWluRGlmZikge1xuICAgICAgbWluRGlmZiA9IGRpZmZcbiAgICAgIGNsb3Nlc3QgPSBjYXJkaW5hbFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjbG9zZXN0XG59XG5cblxuXG4iXSwibmFtZXMiOlsiVEhSRUUiLCJFTEVNRU5UX1RFTVBMQVRFUyIsIkFkdmFuY2VkUGxhY2VtZW50TWFuYWdlciIsInVwZGF0ZU1vdXNlUG9zaXRpb24iLCJjbGllbnRYIiwiY2xpZW50WSIsImNhbnZhc1JlY3QiLCJtb3VzZSIsIngiLCJsZWZ0Iiwid2lkdGgiLCJ5IiwidG9wIiwiaGVpZ2h0IiwicmF5Y2FzdGVyIiwic2V0RnJvbUNhbWVyYSIsImNhbWVyYSIsImludGVyc2VjdHMiLCJpbnRlcnNlY3RPYmplY3RzIiwic2NlbmUiLCJjaGlsZHJlbiIsImxlbmd0aCIsInBvaW50IiwiaW50ZXJzZWN0aW9uIiwiVmVjdG9yMyIsImhpdCIsInJheSIsImludGVyc2VjdFBsYW5lIiwiZ3JvdW5kUGxhbmUiLCJmaW5kU25hcFBvaW50cyIsInBvc2l0aW9uIiwiZWxlbWVudHMiLCJ0ZW1wbGF0ZUlkIiwic25hcFBvaW50cyIsInRlbXBsYXRlIiwiZ3JpZFgiLCJNYXRoIiwicm91bmQiLCJncmlkU2l6ZSIsImdyaWRaIiwieiIsInB1c2giLCJ0eXBlIiwiY29uZmlkZW5jZSIsImRlc2NyaXB0aW9uIiwiZWxlbWVudCIsIm1ldGFkYXRhIiwiaXNQcmV2aWV3IiwiZWxlbWVudFBvcyIsImRpc3RhbmNlIiwiZGlzdGFuY2VUbyIsInNuYXBUb2xlcmFuY2UiLCJ3YWxsU3RhcnQiLCJ3YWxsRW5kIiwiZGltZW5zaW9ucyIsIndhbGxDZW50ZXIiLCJjbG9uZSIsImxlcnAiLCJ3YWxsUXVhcnRlcjEiLCJ3YWxsUXVhcnRlcjMiLCJpZCIsInNsaWNlIiwid2FsbExlbmd0aCIsIndhbGxEaXJlY3Rpb24iLCJzdWIiLCJub3JtYWxpemUiLCJpIiwiaW50ZXJ2YWxQb2ludCIsImFkZCIsIm11bHRpcGx5U2NhbGFyIiwid2FsbFZlY3RvciIsInBlcnBlbmRpY3VsYXIiLCJhdHRhY2hQb2ludDEiLCJkZWZhdWx0RGltZW5zaW9ucyIsImF0dGFjaFBvaW50MiIsIm5vcm1hbCIsInNvcnQiLCJhIiwiYiIsImdldEJlc3RTbmFwUG9pbnQiLCJjcmVhdGVQcmV2aWV3RWxlbWVudCIsInJvdGF0aW9uIiwic25hcFBvaW50IiwiZmluYWxQb3NpdGlvbiIsImZpbmFsUm90YXRpb24iLCJhbmdsZSIsImF0YW4yIiwiZGVwdGgiLCJjb2xvciIsImRlZmF1bHRDb2xvciIsIm1hdGVyaWFsIiwic25hcEVsZW1lbnQiLCJ2YWxpZGF0ZVBsYWNlbWVudCIsImV4aXN0aW5nRWxlbWVudHMiLCJjb25zdHJhaW50cyIsImVycm9ycyIsImNvbnN0cmFpbnQiLCJuZWFyYnlXYWxscyIsImZpbHRlciIsImVsIiwiZ2V0RWxlbWVudERpc3RhbmNlIiwiaG9zdFdhbGwiLCJmaW5kIiwiaXNFbGVtZW50SW5zaWRlV2FsbCIsInZhbGlkIiwiZWwxIiwiZWwyIiwicG9zMSIsInBvczIiLCJ3YWxsIiwiVmVjdG9yMiIsImRpc3RUb1dhbGwiLCJkaXN0YW5jZVRvU3F1YXJlZCIsInVwZGF0ZUNhbWVyYSIsInVwZGF0ZVNjZW5lIiwiY29uc3RydWN0b3IiLCJSYXljYXN0ZXIiLCJQbGFuZSIsImdldFBsYWNlbWVudENvbnN0cmFpbnRzIiwiZ2V0TmV4dFJvdGF0aW9uIiwiY3VycmVudFJvdGF0aW9uIiwic3RlcCIsIlBJIiwiZ2V0UHJldmlvdXNSb3RhdGlvbiIsInNuYXBSb3RhdGlvblRvQ2FyZGluYWwiLCJjYXJkaW5hbHMiLCJjbG9zZXN0IiwibWluRGlmZiIsImFicyIsImNhcmRpbmFsIiwiZGlmZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/advanced-placement.ts\n"));

/***/ })

}]);